<!DOCTYPE html>
<html onclick="start()">

<head>
  <title>Bouncing Ball</title>
  <style>
    html,
    body {
      background: black;
      color: white;
      text-align: center;
      font-family: 'Courier New', Courier, monospace;
      font-size: 24px;
    }

    h1 {
      margin-top: 200px;
    }
  </style>
</head>

<body>
  <h1>Ball gets bigger until my computer crashes ðŸ’€</h1>
  <canvas id="canvas"></canvas>
  <p>Bounces: <span id="bounceCount">0</span></p>
  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/build/Midi.js"></script>
  <script type="module">
    import { Soundfont } from 'https://cdn.jsdelivr.net/npm/smplr@0.12.2/+esm'

    class Song {
      constructor(midiUrl) {
        this.midiUrl = midiUrl
        this.instrument = 'acoustic_grand_piano'

        this.ac = undefined
        this.instruments = undefined
        this.notesByTime = undefined
        this.noteKeysInOrder = undefined
        this.currentNoteIndex = 0
      }

      async setup() {
        const midiData = await Midi.fromUrl(this.midiUrl)
        this.ac = new AudioContext()

        // array of instruments for each track
        let player = new Soundfont(this.ac, { instrument: this.instrument })

        this.instruments = midiData.tracks.map(track => player)

        // { 0.25: [ null, note, null, null], 2.25: []... and so on }
        this.notesByTime = {}

        midiData.tracks.forEach((track, i) => {
          track.notes.forEach(note => {
            // round note time to nearest 0.1
            const time = Math.round(note.time * 10) / 10

            if (!this.notesByTime[time]) {
              // this makes an array with an entry for each track, presetting all values to null
              this.notesByTime[time] = new Array(midiData.tracks.length).fill(null)
            }

            // set the note in the array for the track
            this.notesByTime[time][i] = note
          })
        })

        this.noteKeysInOrder = Object.keys(this.notesByTime).sort((a, b) => a - b)
      }

      playNote() {
        let note = this.notesByTime[this.noteKeysInOrder[this.currentNoteIndex]]

        note.forEach((note, i) => {
          if (note) {
            this.instruments[i].start({ note: note.midi, velocity: note.velocity * 127, time: this.ac.currentTime, duration: note.duration })
          }
        })

        this.currentNoteIndex++

        if (this.currentNoteIndex >= this.noteKeysInOrder.length) {
          this.currentNoteIndex = 0
        }
      }
    }

    function clearCanvas(ctx, width, height) {
      ctx.clearRect(0, 0, width, height)
    }

    function drawCircle(ctx, circle) {
      ctx.beginPath()
      ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI)

      if (circle.fillColor) {
        ctx.fillStyle = circle.fillColor
        ctx.fill()
      }

      if (circle.strokeColor && circle.lineWidth) {
        ctx.lineWidth = circle.lineWidth
        ctx.strokeStyle = circle.strokeColor
        ctx.stroke()
      }
    }

    function isCircleTouchingFromInside(innerCircle, outerCircle) {
      let dx = innerCircle.x - outerCircle.x
      let dy = innerCircle.y - outerCircle.y

      let euclidianDistance = Math.sqrt(dx * dx + dy * dy)

      return euclidianDistance + innerCircle.radius >= outerCircle.radius
    }

    function positionInnerCircleAtClosestTouchingPoint(innerCircle, outerCircle) {
      let dx = innerCircle.x - outerCircle.x
      let dy = innerCircle.y - outerCircle.y

      let distance = Math.sqrt(dx * dx + dy * dy)

      if (distance > outerCircle.radius - innerCircle.radius) {
        let directionX = dx / distance
        let directionY = dy / distance

        innerCircle.x = outerCircle.x + directionX * (outerCircle.radius - innerCircle.radius)
        innerCircle.y = outerCircle.y + directionY * (outerCircle.radius - innerCircle.radius)
      }
    }

    function bounce(innerCircle, outerCircle, bounciness) {
      let dx = innerCircle.x - outerCircle.x
      let dy = innerCircle.y - outerCircle.y

      let distance = Math.sqrt(dx * dx + dy * dy)
      dx /= distance
      dy /= distance

      let angle = Math.atan2(dy, dx)

      let randomAngle = (Math.random() - 0.5) * Math.PI / 4 // random value between -45 and 45 degrees

      angle += randomAngle

      innerCircle.vx = -Math.cos(angle) * bounciness
      innerCircle.vy = -Math.sin(angle) * bounciness
    }

    let hue = 0

    function randomColor() {
      hue = (hue + 3) % 360
      return `hsl(${hue}, 100%, 50%)`
    }

    let c = document.getElementById('canvas')
    let ctx = c.getContext('2d')

    const fps = 60

    const width = 600
    const height = 600

    let bounciness = 30
    let gravity = 1

    // retina scaling
    let dpr = window.devicePixelRatio || 1
    c.width = width * dpr
    c.height = height * dpr
    c.style.width = `${width}px`
    c.style.height = `${height}px`
    ctx.scale(dpr, dpr)

    let outerCircle = {
      x: width / 2,
      y: height / 2,
      vx: 0,
      vy: 0,
      radius: width / 2.1,
      lineWidth: 2,
      strokeColor: 'white',
      fillColor: ''
    }

    let innerCircle = {
      x: width / 2,
      y: height / 2,
      vx: Math.random(), // randomize to start
      vy: Math.random(),
      radius: width / 32,
      fillColor: 'white'
    }

    window.start = async function start() {
      let song = new Song('https://cloud-lbr61k8wj-hack-club-bot.vercel.app/0never-gonna-give-you-up-3.mid')
      await song.setup()

      setInterval(() => {
        innerCircle.vy += gravity

        innerCircle.y += innerCircle.vy
        innerCircle.x += innerCircle.vx

        let color = randomColor()
        innerCircle.fillColor = color
        outerCircle.strokeColor = color

        if (isCircleTouchingFromInside(innerCircle, outerCircle)) {
          positionInnerCircleAtClosestTouchingPoint(innerCircle, outerCircle)

          song.playNote()

          innerCircle.radius += 1
          bounciness *= 1.01
          bounce(innerCircle, outerCircle, bounciness)

          document.getElementById('bounceCount').innerText = parseInt(document.getElementById('bounceCount').innerText) + 1
        }

        clearCanvas(ctx, width, height)

        drawCircle(ctx, outerCircle)
        drawCircle(ctx, innerCircle)
      }, 1000 / fps)
    }

  </script>
</body>

</html>